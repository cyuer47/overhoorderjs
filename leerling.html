<!doctype html>
<html lang="nl">
  <head>
    <meta charset="utf-8" />
    <title>Leerling</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="assets/css/styles.css" />
    <link
      href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap"
      rel="stylesheet"
    />
    <style>
      /* Improved learner page styling */
      .question-card {
        background: linear-gradient(135deg, #5b3e99 0%, #7c4db6 100%);
        color: #fff;
        padding: 30px 20px;
        border-radius: 18px;
        text-align: center;
        box-shadow: 0 12px 34px rgba(103, 80, 164, 0.18);
      }
      .score-display {
        background: linear-gradient(180deg, #fff, #fbfbff);
        padding: 16px;
        border-radius: 12px;
        text-align: center;
        margin-bottom: 18px;
        border: 1px solid rgba(103, 80, 164, 0.06);
      }
      .score-display h3 {
        margin: 0 0 6px 0;
      }
      .score-display #score-display {
        font-size: 20px;
        font-weight: 800;
        color: #2b225c;
      }

      .answer-form {
        background: #fff;
        padding: 18px;
        border-radius: 12px;
        border: 1px solid rgba(103, 80, 164, 0.08);
        margin-top: 18px;
        box-shadow: 0 6px 18px rgba(103, 80, 164, 0.04);
      }
      .answer-form input {
        font-size: 18px;
        padding: 14px;
        text-align: center;
        border: 1px solid #e9e6f7;
        border-radius: 10px;
        width: 100%;
        box-sizing: border-box;
      }
      .answer-form input:focus {
        border-color: #6750a4;
        outline: none;
        box-shadow: 0 0 0 3px rgba(103, 80, 164, 0.08);
      }
      .answer-form button {
        font-size: 18px;
        padding: 14px 20px;
        width: 100%;
        margin-top: 12px;
        color: white;
        background: linear-gradient(135deg, #6b4bd1 0%, #7c5ee0 100%);
        font-weight: 800;
        border-radius: 12px;
        border: none;
        cursor: pointer;
        box-shadow: 0 8px 26px rgba(103, 80, 164, 0.12);
      }
      .answer-form button:hover {
        transform: translateY(-2px);
      }

      .status-message {
        padding: 12px 20px;
        border-radius: 8px;
        margin: 12px 0;
        text-align: center;
        font-weight: 700;
      }
      .status-success {
        background: #d4edda;
        color: #155724;
      }
      .status-error {
        background: #f8d7da;
        color: #721c24;
      }
      .status-info {
        background: #d1ecf1;
        color: #0c5460;
      }

      .waiting-screen {
        text-align: center;
        padding: 48px 20px;
        color: #666;
      }
      .spinner {
        border: 4px solid #f3f3f4;
        border-top: 4px solid #6750a4;
        border-radius: 50%;
        width: 48px;
        height: 48px;
        animation: spin 1s linear infinite;
        margin: 16px auto;
      }

      .completed-screen {
        text-align: center;
        padding: 28px 16px;
        background: #f6e6ff;
        border-radius: 12px;
        border: 1px solid rgba(103, 80, 164, 0.08);
      }

      .recent-answers {
        max-height: 260px;
        overflow-y: auto;
        margin-top: 12px;
      }
      .answer-item {
        padding: 12px;
        margin: 8px 0;
        background: linear-gradient(180deg, #fff, #fbfbff);
        border-radius: 10px;
        border-left: 4px solid #eee;
        box-shadow: 0 6px 18px rgba(43, 34, 92, 0.04);
      }

      /* Logout button */
      #logout-btn {
        position: absolute;
        right: 18px;
        top: 18px;
      }
      .logout-btn {
        color: #d9534f;
        font-weight: 700;
        padding: 8px 12px;
        border-radius: 8px;
      }

      @keyframes spin {
        from {
          transform: rotate(0deg);
        }
        to {
          transform: rotate(360deg);
        }
      }

      @media (max-width: 520px) {
        .question-card {
          padding: 18px;
        }
        .answer-form button {
          padding: 12px;
        }
      }

      /* Toets (exam) fullscreen UI */
      #toets-banner {
        display: none;
        position: fixed;
        left: 50%;
        transform: translateX(-50%);
        top: 12px;
        background: linear-gradient(180deg, #ffdede, #ffecec);
        color: #7a1414;
        padding: 8px 14px;
        border-radius: 999px;
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.12);
        z-index: 1100;
        font-weight: 700;
      }
      #toets-banner .status-dot {
        display: inline-block;
        width: 10px;
        height: 10px;
        border-radius: 50%;
        margin-right: 8px;
        background: #7a1414;
      }
      #toets-overlay {
        display: none;
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.6);
        color: #fff;
        z-index: 1200;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 24px;
      }
      #toets-overlay .card {
        max-width: 520px;
        text-align: center;
        padding: 20px;
        background: linear-gradient(180deg, #fff, #f6f6ff);
        color: #1c1b1f;
      }
      #toets-overlay .btn-primary {
        min-width: 220px;
      }

      /* Freeze state: when student leaves tab or exits fullscreen during toets */
      #toets-freeze {
        display: none;
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.85);
        color: #fff;
        z-index: 1300;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 24px;
      }
      #toets-freeze .card {
        max-width: 720px;
        text-align: center;
        padding: 32px;
        background: rgba(255, 255, 255, 0.06);
        border-radius: 12px;
        backdrop-filter: blur(6px);
      }
      #toets-freeze h2 {
        margin-top: 0;
        color: #ffdede;
      }
      #toets-freeze p {
        color: #fff;
        opacity: 0.95;
      }
      #toets-freeze .btn-primary {
        min-width: 220px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="card" id="join-card">
        <h2>Leerling: doe mee</h2>
        <div
          id="error-message"
          class="status-message status-error"
          style="display: none"
        ></div>
        <form id="join-form">
          <label>Klascode</label><input name="join_klascode" required />
          <label>Naam</label><input name="naam" required />
          <div style="margin-top: 12px">
            <button class="btn-primary" type="submit">Deelnemen</button>
          </div>
        </form>
      </div>
      <div class="card" id="main-card" style="display: none">
        <a href="#" id="logout-btn" class="logout-btn">Uitloggen</a>
        <div class="score-display">
          <div
            style="
              display: flex;
              align-items: center;
              justify-content: space-between;
              gap: 12px;
            "
          >
            <div>
              <h3>Jouw Score</h3>
              <div id="score-display">Laden...</div>
              <p id="answer-count">Laden...</p>
            </div>
            <div style="text-align: right">
              <div
                id="connection-indicator"
                class="connection-indicator disconnected"
              >
                <span class="dot"></span>Offline
              </div>
              <div
                style="
                  font-size: 12px;
                  color: var(--on-surface-variant);
                  margin-top: 6px;
                "
              >
                Live verbinding
              </div>
            </div>
          </div>
        </div>
        <div id="question-section" style="display: none">
          <h3>Beantwoord de vraag:</h3>
          <p id="question-text">...</p>
          <input
            type="text"
            id="answer-input"
            placeholder="Typ hier je antwoord..."
          />
          <button id="submit-btn" class="btn-primary">Verstuur Antwoord</button>
        </div>
        <div id="waiting-section" style="display: none">
          <h3>Wachten op de volgende vraag</h3>
          <div class="spinner"></div>
        </div>
        <div id="completed-section" style="display: none">
          <h3>Vraag beantwoord!</h3>
          <p id="completed-question">...</p>
          <p id="completed-subtitle">
            Je hebt deze vraag beantwoord. Wacht op beoordeling...
          </p>
        </div>
        <div>
          <h3>Jouw recente antwoorden</h3>
          <div id="recent-answers">Laden...</div>
        </div>
      </div>

      <div id="toets-banner">
        <span class="status-dot"></span>Toetsmodus actief — fullscreen verplicht
      </div>

      <div id="toets-overlay" aria-hidden="true">
        <div class="card">
          <h3>Enter toetsmodus</h3>
          <p>
            De docent heeft de toets gestart. Om mee te doen moet je in
            fullscreen werken. Klik op de knop hieronder om fullscreen te
            activeren.
          </p>
          <div
            style="
              margin-top: 16px;
              display: flex;
              gap: 8px;
              justify-content: center;
            "
          >
            <button id="enter-fullscreen-btn" type="button" class="btn-primary">
              Start toets (Full screen)
            </button>
            <button id="leave-toets-btn" type="button" class="btn-text">
              Stop deelnemen
            </button>
          </div>
          <div
            id="toets-fullscreen-error"
            class="error"
            role="alert"
            style="
              display: none;
              margin-top: 10px;
              text-align: center;
              color: var(--danger);
            "
          ></div>
        </div>
      </div>

      <div id="toets-freeze" aria-hidden="true">
        <div class="card">
          <h2>Je hebt de sessie verlaten</h2>
          <p>
            Je bent niet meer actief in deze tab of je bent uit fullscreen
            gegaan tijdens de toets. De docent wordt hiervan op de hoogte
            gesteld en je toegang is tijdelijk geblokkeerd totdat je terugkeert.
          </p>
          <div
            style="
              margin-top: 18px;
              display: flex;
              gap: 8px;
              justify-content: center;
            "
          >
            <button id="retry-fullscreen-btn" type="button" class="btn-primary">
              Probeer opnieuw (Full screen)
            </button>
            <button id="leave-freeze-btn" type="button" class="btn-text">
              Stop deelname
            </button>
          </div>
          <div
            id="toets-freeze-error"
            class="error"
            role="alert"
            style="
              display: none;
              margin-top: 10px;
              text-align: center;
              color: var(--danger);
            "
          ></div>
        </div>
      </div>
    </div>
    <script>
      // Student flow using the Node.js API
      const JOIN_FORM = document.getElementById("join-form");
      const JOIN_CARD = document.getElementById("join-card");
      const MAIN_CARD = document.getElementById("main-card");
      const LOGOUT_BTN = document.getElementById("logout-btn");

      function showJoin() {
        JOIN_CARD.style.display = "";
        MAIN_CARD.style.display = "none";
        // Ensure toets overlays and handlers are cleared while on the join/login screen
        try {
          hideToetsOverlay();
          hideFreezeOverlay();
          disableToetsMode();
        } catch (e) {}
      }
      function showMain() {
        JOIN_CARD.style.display = "none";
        MAIN_CARD.style.display = "";
      }

      // Replace legacy beacons/status endpoints with Node route
      function updateStatus(status) {
        const leerling_id = localStorage.getItem("leerling_id");
        const klas_id = localStorage.getItem("klas_id");
        if (!leerling_id || !klas_id) return;
        // best-effort send
        try {
          navigator.sendBeacon(
            "/status-update",
            new URLSearchParams({ status, leerling_id, klas_id }),
          );
        } catch (e) {}
      }

      // Hook presence events + heartbeat + title updates
      const _origTitle = document.title || "Leerling";
      let _presenceHeartbeat = null;

      function setTitleActive(isActive) {
        if (isActive) document.title = "(Actief) " + _origTitle;
        else document.title = "(Afwezig) " + _origTitle;
      }

      function sendStatus(status, useBeacon = false) {
        try {
          const leerling_id = localStorage.getItem("leerling_id");
          const klas_id = localStorage.getItem("klas_id");
          if (!leerling_id) return;
          if (useBeacon && navigator.sendBeacon) {
            try {
              navigator.sendBeacon(
                "/status-update",
                new URLSearchParams({ status, leerling_id, klas_id }),
              );
              return;
            } catch (e) {
              // fallback
            }
          }
          // JSON POST for regular pings
          fetch("/status-update", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              leerling_id: Number(leerling_id),
              klas_id: Number(klas_id),
              status,
            }),
          }).catch(() => {});
        } catch (e) {}
      }

      function startPresenceHeartbeat() {
        if (_presenceHeartbeat) return;
        sendStatus("actief");
        _presenceHeartbeat = setInterval(() => sendStatus("actief"), 20000);
      }
      function stopPresenceHeartbeat() {
        if (!_presenceHeartbeat) return;
        clearInterval(_presenceHeartbeat);
        _presenceHeartbeat = null;
      }

      window.addEventListener("pagehide", function () {
        sendStatus("closed", true);
        stopPresenceHeartbeat();
        setTitleActive(false);
      });
      document.addEventListener("visibilitychange", () => {
        const isVisible = document.visibilityState === "visible";
        sendStatus(isVisible ? "actief" : "non-actief");
        setTitleActive(isVisible);
        if (isVisible) startPresenceHeartbeat();
        else stopPresenceHeartbeat();
      });
      window.addEventListener("blur", () => {
        sendStatus("non-actief");
        setTitleActive(false);
        stopPresenceHeartbeat();
        if (appState.toetsModeActive) scheduleFreeze("blur");
      });
      window.addEventListener("focus", () => {
        sendStatus("actief");
        setTitleActive(true);
        startPresenceHeartbeat();
        if (appState.toetsModeActive) {
          cancelScheduledFreeze();
          tryRequestFullscreen();
        }
      });

      // Join flow
      JOIN_FORM.addEventListener("submit", async (e) => {
        e.preventDefault();
        const form = e.target;
        const code = (form.join_klascode.value || "").toUpperCase().trim();
        const naam = (form.naam.value || "").trim();
        const em = document.getElementById("error-message");
        em.style.display = "none";
        if (!code || !naam) {
          em.textContent = "Klascode en naam verplicht";
          em.style.display = "";
          return;
        }
        try {
          const res = await fetch("/leerling/join", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ klascode: code, naam }),
          });
          if (!res.ok) {
            const j = await res.json().catch(() => ({}));
            em.textContent = j.error || "Kon niet deelnemen";
            em.style.display = "";
            return;
          }
          const j = await res.json();
          localStorage.setItem("leerling_id", String(j.leerling_id));
          localStorage.setItem("klas_id", String(j.klas_id));
          showMain();
          await updateAppState();
          // if no session yet, start polling to detect session start
          if (!appState.currentSessionId && !sseStream) startSessionPoll();
          // start presence (heartbeat + immediate status)
          sendStatus("actief");
          startPresenceHeartbeat();
        } catch (err) {
          em.textContent = "Netwerkfout";
          em.style.display = "";
        }
      });

      LOGOUT_BTN.addEventListener("click", (e) => {
        e.preventDefault();
        localStorage.removeItem("leerling_id");
        localStorage.removeItem("klas_id");
        location.reload();
      });

      // Submit answer -> POST /sessies/:id/answer
      async function submitAnswer() {
        if (appState.isSubmitting) return;

        const input = document.getElementById("answer-input");
        const button = document.getElementById("submit-btn");
        const answer = input.value.trim();

        if (!answer) {
          showMessage("Vul je antwoord in!", "error");
          input.focus();
          return;
        }
        if (!appState.currentSessionId || !appState.currentQuestionId) {
          showMessage("Geen actieve vraag.", "error");
          return;
        }
        // If this is a toets and fullscreen is required, block submission when not fullscreen or when frozen
        if (
          appState.toetsModeActive &&
          (!document.fullscreenElement || appState.frozen)
        ) {
          if (appState.frozen) {
            showMessage(
              "Je hebt de sessie verlaten. De docent is op de hoogte.",
              "error",
            );
            reportViolation("submit_while_frozen");
          } else {
            showMessage(
              "Full screen vereist tijdens toets. Maak full screen om je antwoord te kunnen verzenden.",
              "error",
            );
            reportViolation("submit_without_fullscreen");
          }
          return;
        }

        appState.isSubmitting = true;
        input.disabled = true;
        button.disabled = true;
        button.textContent = "Versturen...";

        showMessage("Antwoord wordt verstuurd...", "info");

        try {
          const leerling_id = Number(localStorage.getItem("leerling_id"));
          const res = await fetch(
            `/sessies/${appState.currentSessionId}/answer`,
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                leerling_id,
                vraag_id: appState.currentQuestionId,
                antwoord: answer,
              }),
            },
          );
          const j = await res.json();
          if (j.success) {
            showMessage("Antwoord verstuurd!", "success");
            showCompletedState(
              document.getElementById("question-text").textContent,
            );
            updateAppState();
          } else {
            showMessage(j.message || "Fout bij versturen", "error");
            appState.isSubmitting = false;
            input.disabled = false;
            button.disabled = false;
            button.textContent = "Verstuur Antwoord";
          }
        } catch (err) {
          console.error("Submit error:", err);
          showMessage("Netwerkfout. Probeer opnieuw.", "error");
          appState.isSubmitting = false;
          input.disabled = false;
          button.disabled = false;
          button.textContent = "Verstuur Antwoord";
        }
      }

      // State management
      const appState = {
        currentSessionId: null,
        currentQuestionId: null,
        isSubmitting: false,
        lastAnswerIds: new Set(),
        connectionState: "disconnected",
      };

      // Show messages
      function showMessage(text, type) {
        console.log(`[${type}] ${text}`);
        // You can show a toast/notification here if desired
      }

      // Update score display
      function updateScore(score, answerCount) {
        const scoreDisplay = document.getElementById("score-display");
        const answerCountDisplay = document.getElementById("answer-count");
        if (scoreDisplay) scoreDisplay.textContent = `${score} punten`;
        if (answerCountDisplay)
          answerCountDisplay.textContent = `${answerCount} beantwoord`;
      }

      function escapeHtml(s) {
        if (!s) return "";
        return String(s).replace(
          /[&<>\"']/g,
          (c) =>
            ({
              "&": "&amp;",
              "<": "&lt;",
              ">": "&gt;",
              '"': "&quot;",
              "'": "&#39;",
            })[c],
        );
      }

      // Update recent answers (colored badges + new-answer highlight)
      function updateRecentAnswers(answers) {
        const container = document.getElementById("recent-answers");
        if (!container) return;
        if (!answers || answers.length === 0) {
          container.innerHTML = "<p>Nog geen antwoorden</p>";
          appState.lastAnswerIds.clear();
          return;
        }

        const prevIds = new Set(appState.lastAnswerIds);
        const ids = [];

        container.innerHTML = answers
          .map((a) => {
            const id =
              a.id || a.resultaat_id || (a.rid ? a.rid : Math.random());
            ids.push(id);
            const question = escapeHtml(a.question || a.vraag || "Vraag");
            const answer = escapeHtml(
              a.answer || a.antwoord || a.gegeven_antwoord || "—",
            );
            const status = (a.status || "onbekend").toLowerCase();
            const badgeClass =
              status === "goed"
                ? "goed"
                : status === "typfout"
                  ? "typfout"
                  : status === "fout"
                    ? "fout"
                    : "onbekend";
            const isNew = !prevIds.has(id);
            const newClass = isNew ? " new" : "";
            return `
              <div class="answer-item${newClass}" data-id="${id}">
                <div style="display:flex;justify-content:space-between;align-items:center;gap:12px">
                  <div style="flex:1;min-width:0">
                    <strong style="display:block">${question}</strong>
                    <div style="color:#444;margin-top:6px;white-space:normal;overflow-wrap:break-word">${answer}</div>
                    <div style="font-size:12px;color:var(--on-surface-variant);margin-top:6px">${escapeHtml(
                      a.created_at || "",
                    )}</div>
                  </div>
                  <div style="flex:0;margin-left:12px;white-space:nowrap">
                    <span class="status-badge ${badgeClass}">${status}</span>
                  </div>
                </div>
              </div>`;
          })
          .join("");

        // update tracked IDs
        appState.lastAnswerIds = new Set(ids);

        // remove 'new' highlight after a short time
        setTimeout(() => {
          const newEls = container.querySelectorAll(".answer-item.new");
          newEls.forEach((el) => el.classList.remove("new"));
        }, 2200);
      }

      // Show waiting state
      function showWaitingState() {
        const questionSection = document.getElementById("question-section");
        const waitingSection = document.getElementById("waiting-section");
        const completedSection = document.getElementById("completed-section");
        if (questionSection) questionSection.style.display = "none";
        if (waitingSection) waitingSection.style.display = "";
        if (completedSection) completedSection.style.display = "none";
      }

      // Show question state
      function showQuestionState(questionText) {
        const questionSection = document.getElementById("question-section");
        const waitingSection = document.getElementById("waiting-section");
        const completedSection = document.getElementById("completed-section");
        const questionTextDisplay = document.getElementById("question-text");
        const answerInput = document.getElementById("answer-input");
        const submitBtn = document.getElementById("submit-btn");

        if (questionTextDisplay) questionTextDisplay.textContent = questionText;
        if (answerInput) {
          answerInput.value = "";
          answerInput.disabled = false;
        }
        if (submitBtn) {
          submitBtn.disabled = false;
          submitBtn.textContent = "Verstuur Antwoord";
        }
        if (questionSection) questionSection.style.display = "";
        if (waitingSection) waitingSection.style.display = "none";
        if (completedSection) completedSection.style.display = "none";
      }

      // Show completed state
      function showCompletedState(questionText) {
        const questionSection = document.getElementById("question-section");
        const waitingSection = document.getElementById("waiting-section");
        const completedSection = document.getElementById("completed-section");
        const completedQuestionDisplay =
          document.getElementById("completed-question");

        if (completedQuestionDisplay)
          completedQuestionDisplay.textContent = questionText;
        if (questionSection) questionSection.style.display = "none";
        if (waitingSection) waitingSection.style.display = "none";
        if (completedSection) completedSection.style.display = "";
      }

      // Toets mode helpers
      // allow periodic violations but prevent spamming the server: cooldown in ms
      let lastViolationAt = 0;
      const VIOLATION_COOLDOWN_MS = 4000;
      async function reportViolation(reason) {
        try {
          const now = Date.now();
          if (now - lastViolationAt < VIOLATION_COOLDOWN_MS) return; // cooldown
          lastViolationAt = now;

          const leerling_id = Number(localStorage.getItem("leerling_id"));
          const klas_id = Number(localStorage.getItem("klas_id"));
          if (!leerling_id || !klas_id) return;
          // Best-effort: try sendBeacon first
          try {
            navigator.sendBeacon &&
              navigator.sendBeacon(
                "/leerling/violation",
                new URLSearchParams({ leerling_id, klas_id, reason }),
              );
          } catch (e) {}

          const res = await fetch("/leerling/violation", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ leerling_id, klas_id, reason }),
          });
          if (res.ok) {
            const j = await res.json().catch(() => ({}));
            if (j.banned) {
              // If banned, force exit and redirect
              alert("Je bent verwijderd uit de sessie vanwege: " + reason);
              try {
                if (document.fullscreenElement)
                  document.exitFullscreen().catch(() => {});
              } catch (e) {}
              localStorage.removeItem("leerling_id");
              localStorage.removeItem("klas_id");
              window.location = "login.html";
              return;
            } else {
              // show a gentler warning in-page
              // only show alert if visible to user
              try {
                if (document.visibilityState === "visible") {
                  alert(
                    "Waarschuwing geregistreerd: " +
                      (reason || "schending") +
                      ". Als dit zich herhaalt kun je worden verwijderd.",
                  );
                }
              } catch (e) {}
            }
          }
        } catch (err) {
          console.warn("reportViolation error", err);
        }
      }

      let toetsModeEnabled = false;

      // Keep an interval that monitors fullscreen and prompts the student to (re-)enter fullscreen
      let __toets_fullscreen_interval = null;

      function setContentInert(val) {
        const container = document.querySelector(".container");
        if (!container) return;
        Array.from(container.children).forEach((child) => {
          if (!child || !child.id) return;
          if (
            child.id === "toets-overlay" ||
            child.id === "toets-freeze" ||
            child.id === "toets-banner"
          )
            return;
          try {
            if (val) {
              child.setAttribute("inert", "");
              child.setAttribute("aria-hidden", "true");
            } else {
              child.removeAttribute("inert");
              child.removeAttribute("aria-hidden");
            }
          } catch (e) {}
        });
      }

      function showToetsOverlay() {
        // Only show overlay when student is in an active toets session and on the main card (joined)
        if (!appState.currentSessionId || !appState.toetsModeActive) {
          console.debug("showToetsOverlay blocked: no session or not toets", {
            currentSessionId: appState.currentSessionId,
            toetsModeActive: appState.toetsModeActive,
          });
          return;
        }
        const main = document.getElementById("main-card");
        if (main && getComputedStyle(main).display === "none") {
          console.debug("showToetsOverlay blocked: main card not visible");
          return;
        }
        const o = document.getElementById("toets-overlay");
        const b = document.getElementById("toets-banner");

        // make background content inert while overlay is shown, but keep overlays interactive
        setContentInert(true);

        if (o) {
          o.style.display = "flex";
          o.setAttribute("aria-hidden", "false");
          // focus first actionable control for keyboard users
          const enter = document.getElementById("enter-fullscreen-btn");
          if (enter) enter.focus();
        }
        if (b) {
          b.style.display = "block";
        }
      }
      function hideToetsOverlay() {
        const o = document.getElementById("toets-overlay");
        const b = document.getElementById("toets-banner");
        // if focus is inside overlay, move it away before hiding to avoid aria-hidden warnings
        try {
          if (o && o.contains(document.activeElement)) {
            document.activeElement.blur && document.activeElement.blur();
            const fallback =
              document.getElementById("answer-input") || document.body;
            try {
              fallback.focus && fallback.focus();
            } catch (e) {}
          }
        } catch (e) {}

        if (o) {
          o.style.display = "none";
          o.setAttribute("aria-hidden", "true");
        }
        // restore background
        setContentInert(false);

        // Only show the banner when the student is on the main card and a toets session is active
        try {
          if (b) {
            const main = document.getElementById("main-card");
            const mainVisible =
              main && getComputedStyle(main).display !== "none";
            if (
              appState.toetsModeActive &&
              appState.currentSessionId &&
              mainVisible
            ) {
              b.style.display = "block";
            } else {
              b.style.display = "none";
            }
          }
        } catch (e) {}
      }

      function tryEnableToetsMode(sessionId) {
        // If already enabled or no local leerling, skip
        const leerling_id = Number(localStorage.getItem("leerling_id"));
        const klas_id = Number(localStorage.getItem("klas_id"));
        if (!leerling_id || !klas_id) return;
        if (toetsModeEnabled) return;
        // require a sessionId to fully enable toets-mode for this client
        if (!sessionId) return;
        toetsModeEnabled = true;
        appState.toetsModeActive = true;

        // show banner/overlay to prompt for user gesture, only when this student is in the same session
        if (sessionId) {
          if (appState.currentSessionId) {
            if (sessionId === appState.currentSessionId) {
              showToetsOverlay();
            }
          } else {
            // delay show until appState gets updated by updateAppState
            setTimeout(() => {
              if (sessionId === appState.currentSessionId) showToetsOverlay();
            }, 300);
          }
        }

        // attach overlay buttons
        const enterBtn = document.getElementById("enter-fullscreen-btn");
        const leaveBtn = document.getElementById("leave-toets-btn");
        function onEnterClick(e) {
          e.preventDefault();
          try {
            if (document.documentElement.requestFullscreen) {
              const p = document.documentElement.requestFullscreen();
              if (p && p.then) {
                p.then(() => {
                  // entered fullscreen, hide overlay
                  try {
                    hideToetsOverlay();
                    cancelScheduledFreeze();
                  } catch (e) {}
                }).catch((err) => {
                  console.warn("requestFullscreen rejected", err);
                  showFullscreenError(
                    "Fullscreen activeren is mislukt. Controleer je browserinstellingen of druk op F11.",
                  );
                });
              }
            }
          } catch (err) {
            console.warn("requestFullscreen error", err);
            showFullscreenError(
              "Fullscreen activeren is mislukt. Controleer je browserinstellingen of druk op F11.",
            );
          }
        }
        function onLeaveClick(e) {
          e.preventDefault();
          // user voluntarily leaves session
          localStorage.removeItem("leerling_id");
          localStorage.removeItem("klas_id");
          alert("Je deelname is beëindigd.");
          window.location = "login.html";
        }
        enterBtn && enterBtn.addEventListener("click", onEnterClick);
        leaveBtn && leaveBtn.addEventListener("click", onLeaveClick);

        // also try entering fullscreen on any user gesture (some browsers allow if initiated by gesture)
        function onUserGesture(e) {
          tryRequestFullscreen();
        }
        document.addEventListener("click", onUserGesture, true);

        // start limited periodic automatic fullscreen attempts
        startAutoFullscreenAttempts();

        // Prevent some keys/context menu while in toets mode
        function onContext(e) {
          e.preventDefault();
        }
        function onKey(e) {
          const blocked = ["F11", "F12"];
          if (
            blocked.includes(e.key) ||
            (e.ctrlKey && (e.key === "w" || e.key === "t" || e.key === "r"))
          ) {
            e.preventDefault();
            e.stopPropagation();
            reportViolation("blocked_key_" + e.key);
            return false;
          }
        }

        function onFullChange() {
          if (!document.fullscreenElement) {
            // exited fullscreen -> schedule freeze and show overlay
            scheduleFreeze("exited_fullscreen");
            showToetsOverlay();
            // disable input
            const ai = document.getElementById("answer-input");
            const sb = document.getElementById("submit-btn");
            if (ai) ai.disabled = true;
            if (sb) sb.disabled = true;
          } else {
            // entered fullscreen -> cancel freeze and re-enable
            cancelScheduledFreeze();
            hideToetsOverlay();
            const ai = document.getElementById("answer-input");
            const sb = document.getElementById("submit-btn");
            if (ai) ai.disabled = false;
            if (sb) sb.disabled = false;
          }
        }

        function onVisibility() {
          if (document.hidden) {
            scheduleFreeze("visibility_hidden");
          } else {
            // visible again -> cancel freeze attempt and try to reenter fullscreen
            cancelScheduledFreeze();
            tryRequestFullscreen();
          }
        }

        window.addEventListener("keydown", onKey, true);
        window.addEventListener("beforeunload", () => {
          reportViolation("unload");
        });
        document.addEventListener("contextmenu", onContext, true);
        document.addEventListener("fullscreenchange", onFullChange);
        document.addEventListener("visibilitychange", onVisibility);

        // periodic check if fullscreen is present (handles some edge cases)
        __toets_fullscreen_interval = setInterval(() => {
          if (!document.fullscreenElement) {
            scheduleFreeze("no_fullscreen");
            showToetsOverlay();
            const ai = document.getElementById("answer-input");
            const sb = document.getElementById("submit-btn");
            if (ai) ai.disabled = true;
            if (sb) sb.disabled = true;
          } else {
            cancelScheduledFreeze();
          }
        }, 1500);

        // store handlers so we can remove later if needed
        window.__toets_handlers = {
          onKey,
          onContext,
          onFullChange,
          onVisibility,
          onEnterClick,
          onLeaveClick,
          onUserGesture,
        };
      }

      function disableToetsMode() {
        try {
          const h = window.__toets_handlers || {};
          if (h.onKey) window.removeEventListener("keydown", h.onKey, true);
          if (h.onContext)
            document.removeEventListener("contextmenu", h.onContext, true);
          if (h.onFullChange)
            document.removeEventListener("fullscreenchange", h.onFullChange);
          if (h.onVisibility)
            document.removeEventListener("visibilitychange", h.onVisibility);
          if (h.onEnterClick)
            document
              .getElementById("enter-fullscreen-btn")
              ?.removeEventListener("click", h.onEnterClick);
          if (h.onLeaveClick)
            document
              .getElementById("leave-toets-btn")
              ?.removeEventListener("click", h.onLeaveClick);
          if (h.onUserGesture)
            document.removeEventListener("click", h.onUserGesture, true);
        } catch (e) {}
        // clear periodic interval
        if (__toets_fullscreen_interval) {
          clearInterval(__toets_fullscreen_interval);
          __toets_fullscreen_interval = null;
        }
        // clear auto fullscreen attempts
        if (
          typeof __toets_auto_fs_interval !== "undefined" &&
          __toets_auto_fs_interval
        ) {
          clearInterval(__toets_auto_fs_interval);
          __toets_auto_fs_interval = null;
          __toets_auto_fs_attempts = 0;
        }
        // hide overlay/banner and freeze
        try {
          hideToetsOverlay();
        } catch (e) {}
        try {
          hideFreezeOverlay();
        } catch (e) {}
        // ensure the visual banner is hidden when disabling toets mode
        try {
          const b = document.getElementById("toets-banner");
          if (b) b.style.display = "none";
        } catch (e) {}
        // cancel any pending freeze
        try {
          cancelScheduledFreeze();
        } catch (e) {}
        toetsModeEnabled = false;
        appState.toetsModeActive = false;
        appState.frozen = false;
      }

      // Auto-fullscreen retry & freeze logic
      var __toets_auto_fs_interval = null;
      var __toets_auto_fs_attempts = 0;
      const TOETS_AUTO_FS_MAX = 8;
      const TOETS_AUTO_FS_INTERVAL_MS = 2500;
      var __toets_freeze_timeout = null;

      function showFreezeOverlay() {
        // Only show freeze if in an active toets session
        if (!appState.currentSessionId || !appState.toetsModeActive) return;
        const f = document.getElementById("toets-freeze");
        if (!f) return;
        // make background inert (except overlays)
        setContentInert(true);
        f.style.display = "flex";
        f.setAttribute("aria-hidden", "false");
        // focus primary retry button for accessibility
        const retry = document.getElementById("retry-fullscreen-btn");
        if (retry) retry.focus();
        // disable inputs
        const ai = document.getElementById("answer-input");
        const sb = document.getElementById("submit-btn");
        if (ai) ai.disabled = true;
        if (sb) sb.disabled = true;
        appState.frozen = true;
      }

      function hideFreezeOverlay() {
        const f = document.getElementById("toets-freeze");
        const main = document.querySelector(".container");
        if (!f) return;
        try {
          if (f.contains(document.activeElement)) {
            document.activeElement.blur && document.activeElement.blur();
            const fallback =
              document.getElementById("answer-input") || document.body;
            try {
              fallback.focus && fallback.focus();
            } catch (e) {}
          }
        } catch (e) {}
        f.style.display = "none";
        f.setAttribute("aria-hidden", "true");
        if (main) {
          try {
            main.removeAttribute("inert");
            main.removeAttribute("aria-hidden");
          } catch (e) {}
        }
        const ai = document.getElementById("answer-input");
        const sb = document.getElementById("submit-btn");
        if (ai) ai.disabled = false;
        if (sb) sb.disabled = false;
        appState.frozen = false;
      }

      function tryRequestFullscreen() {
        try {
          if (document.fullscreenElement) return true;
          if (document.documentElement.requestFullscreen) {
            const p = document.documentElement.requestFullscreen();
            p && p.catch(() => {});
            return true;
          }
        } catch (e) {}
        return false;
      }

      function showFullscreenError(msg) {
        try {
          const el1 = document.getElementById("toets-fullscreen-error");
          const el2 = document.getElementById("toets-freeze-error");
          if (el1) {
            el1.textContent = msg;
            el1.style.display = "block";
          }
          if (el2) {
            el2.textContent = msg;
            el2.style.display = "block";
          }
          // auto-hide after a short time
          setTimeout(() => hideFullscreenError(), 6000);
        } catch (e) {
          console.warn("showFullscreenError failed", e);
        }
      }

      function hideFullscreenError() {
        try {
          const el1 = document.getElementById("toets-fullscreen-error");
          const el2 = document.getElementById("toets-freeze-error");
          if (el1) {
            el1.textContent = "";
            el1.style.display = "none";
          }
          if (el2) {
            el2.textContent = "";
            el2.style.display = "none";
          }
        } catch (e) {}
      }

      function startAutoFullscreenAttempts() {
        if (__toets_auto_fs_interval) return;
        __toets_auto_fs_attempts = 0;
        __toets_auto_fs_interval = setInterval(() => {
          if (document.fullscreenElement) {
            clearInterval(__toets_auto_fs_interval);
            __toets_auto_fs_interval = null;
            return;
          }
          if (__toets_auto_fs_attempts >= TOETS_AUTO_FS_MAX) {
            clearInterval(__toets_auto_fs_interval);
            __toets_auto_fs_interval = null;
            return;
          }
          __toets_auto_fs_attempts++;
          tryRequestFullscreen();
        }, TOETS_AUTO_FS_INTERVAL_MS);
      }

      function onUserGestureAttemptFullscreen(e) {
        tryRequestFullscreen();
      }

      function scheduleFreeze(reason) {
        // Only schedule freeze when in an active toets session
        if (!appState.toetsModeActive || !appState.currentSessionId) return;
        // small grace (2s) to avoid false positives
        if (__toets_freeze_timeout || appState.frozen) return;
        __toets_freeze_timeout = setTimeout(() => {
          __toets_freeze_timeout = null;
          showFreezeOverlay();
          reportViolation(reason || "left_session");
        }, 2000);
      }

      function cancelScheduledFreeze() {
        if (__toets_freeze_timeout) {
          clearTimeout(__toets_freeze_timeout);
          __toets_freeze_timeout = null;
        }
      }

      // freeze overlay button handlers
      document.addEventListener(
        "click",
        (e) => {
          const target = e.target;
          if (target && target.id === "retry-fullscreen-btn") {
            e.preventDefault();
            // try entering fullscreen and only hide freeze overlay on success
            try {
              if (document.documentElement.requestFullscreen) {
                const p = document.documentElement.requestFullscreen();
                if (p && p.then) {
                  p.then(() => {
                    hideFreezeOverlay();
                    cancelScheduledFreeze();
                    hideFullscreenError();
                  }).catch((err) => {
                    console.warn("retry requestFullscreen rejected", err);
                    showFullscreenError(
                      "Fullscreen activeren is mislukt. Controleer je browserinstellingen of druk op F11.",
                    );
                  });
                } else {
                  // fallback: if we are fullscreen now, hide
                  if (document.fullscreenElement) {
                    hideFreezeOverlay();
                    cancelScheduledFreeze();
                    hideFullscreenError();
                  } else {
                    showFullscreenError(
                      "Fullscreen activeren is niet mogelijk in deze browser.",
                    );
                  }
                }
              } else {
                showFullscreenError(
                  "Fullscreen wordt niet ondersteund door deze browser.",
                );
              }
            } catch (err) {
              console.warn("retry fullscreen error", err);
              showFullscreenError(
                "Een fout trad op bij het activeren van fullscreen.",
              );
            }
          }
          if (target && target.id === "leave-freeze-btn") {
            e.preventDefault();
            localStorage.removeItem("leerling_id");
            localStorage.removeItem("klas_id");
            window.location = "login.html";
          }
        },
        true,
      );

      // Update state from server
      async function updateAppState() {
        const leerlingId = localStorage.getItem("leerling_id");
        const klasId = localStorage.getItem("klas_id");
        if (!leerlingId || !klasId) return;

        try {
          const res = await fetch(
            `/student/state?leerling_id=${encodeURIComponent(
              leerlingId,
            )}&klas_id=${encodeURIComponent(klasId)}`,
          );
          if (!res.ok) {
            if (res.status === 404) {
              // Student not found / banned -> show user-friendly message and clear storage
              showMessage(
                "Je bent niet gevonden of uit de sessie verwijderd. Je wordt uitgelogd.",
                "error",
              );
              localStorage.removeItem("leerling_id");
              localStorage.removeItem("klas_id");
              setTimeout(() => location.reload(), 1200);
              return;
            }
            throw new Error("state failed");
          }
          const data = await res.json();

          if (data.session_ended) {
            // clear local storage and show join
            showMessage(
              "Er is geen actieve sessie meer. Je bent uitgelogd.",
              "info",
            );
            localStorage.removeItem("leerling_id");
            localStorage.removeItem("klas_id");
            setTimeout(() => {
              location.reload();
            }, 1400);
            return;
          }
          if (data.error) {
            console.error("State error:", data.error);
            return;
          }

          updateScore(data.score || 0, data.answer_count || 0);
          updateRecentAnswers(data.recent_answers || []);

          // If a session was created (even without a question) ensure SSE is started
          if (data.session_id && !sseStream) {
            appState.currentSessionId = data.session_id;
            startSSEStream(data.session_id);
            stopSessionPoll();
          }

          // if this session is configured as a toets, ensure student enters toets mode
          if (data.is_toets) {
            tryEnableToetsMode(data.session_id);
          } else {
            // ensure we don't keep handlers if session is not a toets
            disableToetsMode();
          }

          const newQuestionId = data.current_question_id;
          const hasQuestionChanged =
            newQuestionId !== appState.currentQuestionId;

          // If this is the first time a question appears in this session (students were in waiting state), reload once so UI initializes and connection becomes live
          try {
            const prevQ = appState.currentQuestionId;
            if (!prevQ && newQuestionId) {
              const sessId = data.session_id || "";
              const key = `reloaded_on_start_${sessId}`;
              if (!localStorage.getItem(key)) {
                localStorage.setItem(key, "1");
                // small delay to let state settle, then reload
                setTimeout(() => {
                  console.log(
                    "Reloading student page because first question was sent for session",
                    sessId,
                  );
                  location.reload();
                }, 50);
                return; // reload will re-run the logic after page refresh
              }
            }
          } catch (e) {}

          if (hasQuestionChanged) {
            appState.currentQuestionId = newQuestionId;
            appState.isSubmitting = false;
          }

          if (!newQuestionId) showWaitingState();
          else if (data.already_answered)
            showCompletedState(data.question_text);
          else showQuestionState(data.question_text);

          if (newQuestionId && data.already_answered) {
            const subtitle = document.getElementById("completed-subtitle");
            const reveal = document.getElementById("reveal-answer");
            const revealText = document.getElementById("reveal-answer-text");
            if (data.all_answered && data.correct_answer) {
              if (revealText) revealText.textContent = data.correct_answer;
              if (reveal) reveal.style.display = "block";
              if (subtitle)
                subtitle.textContent =
                  "Alle antwoorden binnen! Dit is het juiste antwoord:";
            } else {
              if (reveal) reveal.style.display = "none";
              if (subtitle)
                subtitle.textContent =
                  "Je hebt deze vraag beantwoord. Wacht op beoordeling...";
            }
          }
        } catch (err) {
          console.error("Update error:", err);
        }
      }

      // SSE stream control
      let sseStream = null;
      // Lightweight session polling variables (used when no session exists yet)
      let sessionPollInterval = null;
      let sessionPollTimeoutId = null;

      function setConnectionState(state) {
        appState.connectionState = state;
        const el = document.getElementById("connection-indicator");
        if (!el) return;
        el.classList.remove("connected", "polling", "disconnected");
        if (state === "connected") {
          el.classList.add("connected");
          el.innerHTML = '<span class="dot"></span>Live';
        } else if (state === "polling") {
          el.classList.add("polling");
          el.innerHTML = '<span class="dot"></span>Polling';
        } else {
          el.classList.add("disconnected");
          el.innerHTML = '<span class="dot"></span>Offline';
        }
      }
      // initialize UI state
      setConnectionState(appState.connectionState);

      function startSessionPoll() {
        if (sseStream || sessionPollInterval) return;
        console.log("Starting session poll for new sessions...");
        setConnectionState("polling");
        sessionPollInterval = setInterval(() => {
          updateAppState();
        }, 2000);
        // stop polling after 30s to avoid endless polling
        sessionPollTimeoutId = setTimeout(() => stopSessionPoll(), 30000);
      }

      function stopSessionPoll() {
        if (sessionPollInterval) {
          clearInterval(sessionPollInterval);
          sessionPollInterval = null;
        }
        if (sessionPollTimeoutId) {
          clearTimeout(sessionPollTimeoutId);
          sessionPollTimeoutId = null;
        }
        // revert to disconnected if SSE not connected yet
        if (!sseStream) setConnectionState("disconnected");
      }

      function startSSEStream(sessionId) {
        if (sseStream) return;
        const token = localStorage.getItem("token");
        const url = token
          ? `/sessies/${sessionId}/stream?token=${encodeURIComponent(token)}`
          : `/sessies/${sessionId}/stream`;
        sseStream = new EventSource(url);

        sseStream.addEventListener("open", () => {
          console.log("SSE connected");
          setConnectionState("connected");
          // once SSE is connected, no need to poll
          stopSessionPoll();
        });

        // Listen for both teacher 'session' events and lightweight 'update' events
        sseStream.addEventListener("session", (e) => {
          try {
            const data = JSON.parse(e.data);
            // teacher clients receive full payload; student clients can refetch
            updateAppState();
            // if the session is a toets and not yet in toets mode, enforce fullscreen / monitoring
            if (data && data.sess && data.sess.is_toets) {
              tryEnableToetsMode(data.sess.id);
            }
          } catch (err) {
            console.error("SSE session parse error:", err);
          }
        });

        sseStream.addEventListener("update", (e) => {
          try {
            // update event triggers a fetch for current state
            updateAppState();
          } catch (err) {
            console.error("SSE update parse error:", err);
          }
        });

        // Handle explicit end-toets or lock/violation events
        sseStream.addEventListener("end-toets", (e) => {
          console.log("Received end-toets event");
          try {
            // exit fullscreen and log the student out
            if (document.fullscreenElement) {
              document.exitFullscreen().catch(() => {});
            }
          } catch (err) {}
          // clear local storage and redirect to login (student logged out)
          localStorage.removeItem("leerling_id");
          localStorage.removeItem("klas_id");
          alert("Toets voorbij. Je wordt uitgelogd.");
          window.location = "login.html";
        });

        sseStream.addEventListener("violation", (e) => {
          try {
            const d = JSON.parse(e.data);
            // If we are the removed leerling, ensure we are logged out
            const myId = Number(localStorage.getItem("leerling_id"));
            if (d.leerling_id && d.leerling_id === myId) {
              alert(
                "Je bent verwijderd uit de sessie wegens: " +
                  (d.reason || d.reason || d.rede || d.reden || "schending"),
              );
              localStorage.removeItem("leerling_id");
              localStorage.removeItem("klas_id");
              if (document.fullscreenElement) {
                document.exitFullscreen().catch(() => {});
              }
              window.location = "login.html";
            }
          } catch (err) {
            console.error("violation parse error", err);
          }
        });

        sseStream.addEventListener("lock", (e) => {
          try {
            const d = JSON.parse(e.data);
            console.log("Session lock status changed:", d);
          } catch (err) {}
        });

        sseStream.addEventListener("error", (e) => {
          console.error("SSE error:", e);
          setConnectionState("disconnected");
          // try to reconnect after a short delay if closed
          if (sseStream.readyState === EventSource.CLOSED) {
            console.log("SSE stream closed, attempting reconnect in 3s");
            sseStream = null;
            setTimeout(() => startSSEStream(sessionId), 3000);
          }
        });
      }

      function stopSSEStream() {
        if (sseStream) {
          sseStream.close();
          sseStream = null;
        }
        setConnectionState("disconnected");
      }

      // Initialize on page load
      document.addEventListener("DOMContentLoaded", async () => {
        const leerlingId = localStorage.getItem("leerling_id");
        const klasId = localStorage.getItem("klas_id");
        // Ensure overlays are hidden on load and toets-mode is disabled until confirmed by state
        try {
          hideToetsOverlay();
          hideFreezeOverlay();
        } catch (e) {}
        appState.toetsModeActive = false;

        if (leerlingId && klasId) {
          showMain();
          updateStatus("actief");
          await updateAppState();
          // If there's no active session yet, start a short poll to detect when the docent starts it
          if (!appState.currentSessionId && !sseStream) startSessionPoll();
        } else {
          showJoin();
        }

        // Handle Enter key in input
        document
          .getElementById("answer-input")
          .addEventListener("keypress", (e) => {
            if (e.key === "Enter") {
              e.preventDefault();
              submitAnswer();
            }
          });
        // Submit button click
        document.getElementById("submit-btn").addEventListener("click", (e) => {
          e.preventDefault();
          submitAnswer();
        });
      });

      // Expose submit for inline onclick
      window.submitAnswer = submitAnswer;
    </script>
  </body>
</html>
